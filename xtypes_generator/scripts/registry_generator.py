#!python3

def can_be_used():
    return True


def cant_be_used_msg():
    return "Unknown error!"


INFO = 'Code generator script that creates the registry for the defined xtypes.'

import os
import datetime
import yaml
import argparse
from jinja2 import Environment, PackageLoader, select_autoescape


def create_dir(directory):
    """
    Creates the specified directory. Excepts when there is an OSError during creation
    :param directory: directory to create
    :return: the given directory
    """
    try:
        os.makedirs(directory, exist_ok=True)
    except OSError:
        print('Error: creating directory. ' + directory)
    return directory


def write(file, content):
    """
    Writes the generated file content only when there are relevant changes.
    Unchanged files persist so that the compiler nows they need no rebuild.
    :param file: The filepath where to write
    :param content: The content string
    :return: None
    """
    old_content = None
    if os.path.isfile(file):
        old_content = open(file, "r").read()
    if old_content is None or content.split("\n")[3:] != old_content.split("\n")[3:]:
        os.makedirs(os.path.dirname(file), exist_ok=True)
        with open(file, "w") as f:
            f.write(content)


def collect_classnames(path):
    """
    Checks the given path's content and returns a list of all xtype classnames that are specified there
    :param path: path to a directory
    :return: list of classnames
    """
    classnames = []
    if os.path.isdir(path):
        for f in os.listdir(path):
            filename = os.path.join(path, f)
            if not os.path.isfile(filename):
                continue
            try:
                with open(filename, "r") as ff:
                    content = yaml.safe_load(ff)
            except:
                continue
            if not content:
                continue
            if 'name' in content:
                classnames.append(content['name'])
    return classnames


def main(args):
    parser = argparse.ArgumentParser(description='Collects all xtype classnames and generates a XType Registry')
    parser.add_argument('--project_name', help="The project name", type=str, required=True)
    parser.add_argument('--input_dir', help="The input directory to search for classnames", type=str, default=".")
    parser.add_argument('--output_dir', help="The output directory for the auto generated files.",
                        type=str, default="build/autogenerated_files")
    parser.add_argument('--dependencies', help="The semicolon seperated list of xtype dependencies.",
                        type=str, default="")
    args = parser.parse_args(args)
    jinja_env = Environment(
        loader=PackageLoader("xtypes_generator", "data"),
        autoescape=select_autoescape()
    )
    registry_header_template = jinja_env.get_template("registry.hpp.in")
    # registry_source_template = jinja_env.get_template("registry.cpp.in")
    registry_py_template = jinja_env.get_template("pybind_registry.cpp.in")
    derived_classnames = collect_classnames(args.input_dir)
    if not derived_classnames:
        print(f"No classes found in {args.input_dir}")
        exit(1)
    generator_comment = "Auto-generated with xtypes_generator registry_generator " + datetime.datetime.now().strftime(
        "%m/%d/%Y %H:%M:%S")
    dependencies = [dep for dep in args.dependencies.split(";") if len(dep)>0 and dep != "''" and dep != '""']
    registry_header = registry_header_template.render(generator_comment=generator_comment,
                                                      derived_classnames=derived_classnames, project_name=args.project_name,
                                                      dependencies=dependencies)
    # registry_source = registry_source_template.render(generator_comment=generator_comment,
                                                      # derived_classnames=derived_classnames, project_name=args.project_name)
    registry_py = registry_py_template.render(generator_comment=generator_comment,
                                              derived_classnames=derived_classnames, project_name=args.project_name,
                                              dependencies=dependencies)
    create_dir(args.output_dir)
    result_header_dir = create_dir(os.path.join(args.output_dir, "include"))
    write(os.path.join(result_header_dir, "ProjectRegistry.hpp"), registry_header)
    # result_source_dir = create_dir(os.path.join(args.output_dir, "src"))
    # write(os.path.join(result_source_dir, "ProjectRegistry.cpp"), registry_source)
    result_source_dir = create_dir(os.path.join(args.output_dir, "pybind"))
    write(os.path.join(result_source_dir, "pyProjectRegistry.cpp"), registry_py)
    exit(0)


if __name__ == "__main__":
    import sys
    main(sys.argv)
